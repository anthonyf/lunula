(defpackage :lunula
  ;; Do not import the entire COMMON-LISP package.  Only import
  ;; primitive things that will not be redifened in the LUNULA
  ;; package.  We want to be explicit when we use anything else from
  ;; COMMON-LISP so we can easlily identify it later and implement it
  ;; in the compiler.
  (:import-from :common-lisp
                #:&aux
                #:&body
                #:&key
                #:&optional
                #:&rest
                #:&whole
                #:*
                #:*package*
                #:+
                #:-
                #:/
                #:/=
                #:<
                #:<=
                #:=
                #:>
                #:>=
                #:and
                #:apply
                #:aref
                #:array-dimension
                #:arrayp
                #:assert
                #:block
                #:boundp
                #:car
                #:catch
                #:cdr
                #:char
                #:char-code
                #:char-equal
                #:char=
                #:characterp
                #:code-char
                #:cons
                #:consp
                #:declare
                #:defpackage
                #:defparameter
                #:defvar
                #:eq
                #:error
                #:eval-when
                #:export
                #:fboundp
                #:fdefinition
                #:find-package
                #:funcall
                #:get
                #:if
                #:ignore
                #:in-package
                #:inline
                #:intern
                #:lambda
                #:let
                #:let*
                #:loop ;; only simple loop supported for now
                #:macro-function
                #:macrolet
                #:make-array
                #:make-string
                #:make-symbol
                #:mod
                #:multiple-value-call
                #:nil
                #:numberp
                #:or
                #:otherwise
                #:package-name
                #:progn
                #:quote
                #:return
                #:rplaca
                #:rplacd
                #:setf
                #:setq
                #:string
                #:string-equal
                #:string=
                #:stringp
                #:svref
                #:symbol-function
                #:symbol-name
                #:symbol-package
                #:symbol-value
                #:symbolp
                #:t
                #:throw
                #:truncate
                #:type-of
                #:values
                #:vector
                #:vectorp
                #:zerop
                )
  (:export #:&aux
           #:&body
           #:&key
           #:&optional
           #:&rest
           #:&whole
           #:*
           #:*package*
           #:*read-base*
           #:*read-table*
           #:*standard-input*
           #:*standard-output*
           #:+
           #:-
           #:/
           #:/=
           #:1+
           #:1-
           #:<
           #:<=
           #:=
           #:>
           #:>=
           #:abs
           #:alpha-char-p
           #:and
           #:append
           #:apply
           #:aref
           #:array-dimension
           #:arrayp
           #:assert
           #:assoc
           #:atom
           #:block
           #:both-case-p
           #:boundp
           #:butlast
           #:car
           #:case
           #:catch
           #:cdr
           #:char
           #:char-code
           #:char-downcase
           #:char-equal
           #:char-upcase
           #:char=
           #:characterp
           #:code-char
           #:complement
           #:concatenate
           #:cond
           #:cons
           #:consp
           #:copy-list
           #:decf
           #:declare
           #:defmacro
           #:defpackage
           #:defparameter
           #:defstruct
           #:defun
           #:defvar
           #:defvar
           #:destructuring-bind
           #:digit-char
           #:digit-char-p
           #:do
           #:do*
           #:elt
           #:eq
           #:eql
           #:equal
           #:equalp
           #:error
           #:eval-when
           #:every
           #:export
           #:expt
           #:fdefinition
           #:find-package
           #:first
           #:flet
           #:funcall
           #:get
           #:get-macro-character
           #:if
           #:ignore
           #:in-package
           #:incf
           #:intern
           #:labels
           #:lambda
           #:last
           #:length
           #:let
           #:let*
           #:list
           #:list*
           #:listp
           #:loop
           #:lower-case-p
           #:macro-function
           #:macroexpand-1
           #:make-array
           #:make-string
           #:make-symbol
           #:map
           #:mapc
           #:mapcar
           #:member
           #:minusp
           #:multiple-value-bind
           #:multiple-value-call
           #:multiple-value-list
           #:nconc
           #:nil
           #:not
           #:notany
           #:notevery
           #:nreconc
           #:nreverse
           #:nth
           #:null
           #:numberp
           #:or
           #:otherwise
           #:peek-char
           #:plusp
           #:pop
           #:position
           #:princ-to-string
           #:prog1
           #:progn
           #:psetq
           #:push
           #:pushnew
           #:quote
           #:read
           #:read-char
           #:read-from-string
           #:readtable-case
           #:reduce
           #:rest
           #:return
           #:reverse
           #:rplaca
           #:rplacd
           #:second
           #:set-macro-character
           #:setf
           #:setq
           #:some
           #:string
           #:string=
           #:stringp
           #:subseq
           #:svref
           #:symbol-function
           #:symbol-name
           #:symbol-package
           #:symbol-value
           #:symbolp
           #:t
           #:third
           #:throw
           #:truncate
           #:type-of
           #:unless
           #:unread-char
           #:upper-case-p
           #:values
           #:values-list
           #:vector
           #:vectorp
           #:when
           #:with-input-from-string
           #:write-char
           #:zerop
           ))

(defpackage :lunula-user
  (:use :lunula))

;;;; common lisp special forms
;; block      let*                  return-from
;; catch      load-time-value       setq
;; eval-when  locally               symbol-macrolet
;; flet       macrolet              tagbody
;; function   multiple-value-call   the
;; go         multiple-value-prog1  throw
;; if         progn                 unwind-protect
;; labels     progv
;; let        quote                
